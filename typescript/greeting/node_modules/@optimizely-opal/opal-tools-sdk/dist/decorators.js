"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tool = tool;
require("reflect-metadata");
const models_1 = require("./models");
const registry_1 = require("./registry");
/**
 * Map a TypeScript type to a ParameterType
 * @param type TypeScript type
 */
function mapTypeToParameterType(type) {
    if (type === String || type.name === 'String') {
        return models_1.ParameterType.String;
    }
    else if (type === Number || type.name === 'Number') {
        return models_1.ParameterType.Number;
    }
    else if (type === Boolean || type.name === 'Boolean') {
        return models_1.ParameterType.Boolean;
    }
    else if (type === Array || type.name === 'Array') {
        return models_1.ParameterType.List;
    }
    else if (type === Object || type.name === 'Object') {
        return models_1.ParameterType.Dictionary;
    }
    // Default to string
    return models_1.ParameterType.String;
}
/**
 * Extract parameters from a TypeScript interface
 * @param paramType Parameter type object
 */
function extractParameters(paramType) {
    const parameters = [];
    // This is very basic and doesn't handle complex types
    // For production use, this would need to be more sophisticated
    for (const key in paramType) {
        if (paramType.hasOwnProperty(key)) {
            const type = typeof paramType[key] === 'undefined' ? String : paramType[key].constructor;
            const required = true; // In a real implementation, we'd detect optional parameters
            parameters.push(new models_1.Parameter(key, mapTypeToParameterType(type), '', // Description - in a real impl we'd use TypeDoc or similar
            required));
        }
    }
    return parameters;
}
/**
 * Decorator to register a function as an Opal tool
 * @param options Tool options including:
 *   - name: Name of the tool
 *   - description: Description of the tool
 *   - authRequirements: (Optional) Authentication requirements
 *     Format: { provider: "oauth_provider", scopeBundle: "permissions_scope", required: true }
 *     Example: { provider: "google", scopeBundle: "calendar", required: true }
 *
 * Note: If your tool requires authentication, define your handler function with two parameters:
 * ```
 * async function myTool(parameters: ParameterInterface, authData?: any): Promise<any> {
 *   // Your tool implementation
 * }
 * ```
 */
function tool(options) {
    return function (target, propertyKey, descriptor) {
        const isMethod = propertyKey && descriptor;
        const handler = isMethod ? descriptor.value : target;
        // Generate endpoint from name - ensure hyphens instead of underscores
        const endpoint = `/tools/${options.name.replace(/_/g, '-')}`;
        // Convert parameter definitions to Parameter objects
        const parameters = [];
        if (options.parameters && options.parameters.length > 0) {
            // Use the explicitly provided parameter definitions
            for (const paramDef of options.parameters) {
                parameters.push(new models_1.Parameter(paramDef.name, paramDef.type, paramDef.description, paramDef.required));
            }
        }
        // Create auth requirements if specified
        let authRequirements;
        if (options.authRequirements) {
            authRequirements = [
                new models_1.AuthRequirement(options.authRequirements.provider, options.authRequirements.scopeBundle, options.authRequirements.required ?? true)
            ];
        }
        // Register the tool with all services
        for (const service of registry_1.registry.services) {
            service.registerTool(options.name, options.description, handler, parameters, endpoint, authRequirements);
        }
        return isMethod ? descriptor : target;
    };
}
